Інструкція до роботи з цим пакетом

 - База даних - Postgres.
 - База працює на комп"ютері з допомогою докер-контейнера, керую контейнером через DockerDesktop.
 - Докер-контейнер створюється з допомогою CommandPrompt.
 - Використовую DBeaverv для перегляду бази даних і таблиць у ній.
 - Для роботи з кодом використовую Visual Studio Code.

1. Postgres 
Створюємо venv (команда в консолі python -m venv venv)
2. Активуємо venv
3. Встановлюємо всі пакети, що будуть необхідні: в консолі - pip install sqlalchemy alembic faker psycopg2

4. В папці "app" знаходяться 2 файли:
db.py - тут створений канал зв"язку з базою даних.
db_models.py - в ньому описані моделі наших таблиць бази даних, ці моделі використовує Алембік для створення всіх таблиць в базі.
10. В папці app створюємо файлик "db.py", в якому опишемо підключення, і це буде в нас генератором сесій.
11. В файл "db_models.py" заімпортимо db.py, але трішки пізніше.
Зараз прописуємо класи для майбутніх таблиць в базі даних. В нас будуть клієнти, в яких будуть адреси. 
Відношення 1:багатьох - в 1 клієнта м.бути багато адрес.
12. Генерація даних. Можна Фейкером скористатися.
Створюємо папку "seed", в якій нагенеримо даних, які будуть записуватися в базу даних. В цій папці створюємо файл 
"make_fake_data.py", куди ми складемо дані для нашої бази даних.
13. В консолі - pip install Faker
14. У файлі "make_fake_datas.py" пишемо скрипт, який заповнить нам дані в базу.
15. Хочемо запустити скрипт отак: в консолі "py .\seed\make_fake_datas.py" -> видає помилку
"ModuleNotFoundError: No module named 'app'". Як вирішити:
 - в консолі пишемо "set PYTHONPATH=." - встановлюємо змінну середовища. Ой, не вистачає "psycopg2" -> 
-> "pip unstall psycopg2". Але в мене пішло щось не так, і взагалі не було ніяких виконань від консолі, коли я вводила 
"set PYTHONPATH=.", це все просто не працює чомусь, чат GPT теж не зміг допомогти. Тому я створила 2 файли __init__.py
 - в папці, ЗВІДКИ я імпортую всередині файлу make_fake_datas.py, і в кореневій папці проекту. І все запрацювало.
16. Після запуску make_fake_data.py нагенерилися дані, щоб їх було застосовано - треба зробити session.add(client) і 
session.commit(). Робимо - і помилка, бо ще немає створених таблиць.
17. В даному випадку в нас в базі є таблиці з минулого заняття - тому їх видаляємо.
18. Створюємо потрібні нам таблиці через Алембік, він нам зробить міграцію. Можемо ці таблиці зробити руками самі в 
DBeaver. Але ж ми вчимо алембік :) 
Тому: ідемо в файл alembic.ini і пропишемо sqlalchemy_url - шлях до бази даних, можемо взяти його з файлу db.py, бо вже 
ж його маємо.
19. Найпростіше, що можна зробити алембіком - це згенерувати першу ревізію. Для цього в консолі:
alembic revision -m "first_revision"
Алембік щось зробтив і все поклав у папку "versions" у файлі "first_revesion"
20. Заходимо в цей файл "first_revesion" і дивимося, що він зробив - а там він зробив 2 порожні методи downgrade і
upgrade. Тепер теоретично можна сюди руками вписати, що і як робити, але це не дуже правильно. Тому ми зараз цей файл
видалимо (видаляти обидва файли) і налаштуємо алембік на автоматичну роботу.
21. Для автоматичної роботи Алембіка нам достатньо в файлі env.py вказати target_metadata. Метадата в нас знаходиться в 
DB, class Base, metadata.
Дописуємо в потрібних місцях:
from app import db_models
target_metadata = db_models.Base.metadata
22. І тепер знову запускаємо команду в консолі, тільки тепер з приставкою "--autogenerate":
alembic revision --autogenerate -m "first_revision"
Коли відбувається автогенерація, то відбувається вхід у файл env.py у функцію run_migration_online, можна перевірити 
прінтом одразу при вході в цю функцію: print("Run online migration")
Тепер знов створились файлики, і тепер в тих функціях вже все написано, нічого не рухайте, вже все є (мають створитись 
SQL-команди автоматично, які все мають виконати в базі даних).
А в базі даних створилась табличка "alembic_versions" (дивимося через DBeaver).
22. Правою кнопкою миші на таблиці "alembic_versions" зліва -> View data.
Поки що версій немає, але як тільки ми застосуємо наші зміни, тут буде все відображатися.
23. Застосовуємо зміни. В консолі набираємо команду: alembic upgrade head
і в табличці "alembic_versions" через DBeaver бачимо, що з"явилася інфо. 
24. Коли наст.разу треба буде зробити апдейт, ми знову робимо автодженерейт, алембік створює ще одну ревізію, і на цю 
ревізію апгрейдимося.
25. Тепер зробимо файл main.py (по суті, там лише точка входу, яка запускає все інше) і запускаємо його. Тепер повністю
згенерувалися наші таблички.

Відношення "many : many" - викладачу подобається шляхом створення окремого класу асоціативної таблиці, тобто 
реалізується через зовнішню таблицю. Напр., відношення товарів до клієнтів: будь-який клієнт може замовити будь-які 
товари. І так само будь-який товар може відноситися до будь-якого клієнта.
Як реалізується.
В файлі db_models.py пишемо окремий клас class Goods(Base).
Також робимо клас class GoodsForClient(Base), - описуватиме дві колонки, де опишемо id, що відповідають одна одній.
Також у файлі make_fake_data.py дописуємо функцію заповнення таблиці товарів.
Тепер зможемо створити список товарів.
Тепер зробимо ще одну функцію def goods_for_clients

Щоб повністю перевірити роботу всього цього доданого, видалимо в дібівері всі вже створені таблиці. 
В файлі main.py викличемо новоств.ф-ції make_fake_goods, запустимо, і в базі створюються всі таблиці.




Volodymyr DunkinVolodymyr Dunkin  12:04 AM@channel
Доброї ночі)
Як завжди, все дуже просто)
Мені здається, ми це пробували на лекції)
У файл env.py має бути імпортований модуль з моделями.
Тому імпорт меє виглядати ось так
from app import db_models [саме моделі мають бути імпортовані!!!]
ну і отримання метадати буде таке 
target_metadata =db_models.Base.metadata
З many-to-many теж ми все правильно зробили, просто я неправильно визначив самі моделі при створенні. Кидаю вам 
посилання на репозиторій, там все працює. Якщо буде не зрозуміло - у вівторок залишемо 30 хвилин на розбір.
Також даю посилання на додатковий матеріал.В репозиторії - змінюєте підключення до БД, а потім виконуєте
alembic revision --autogenerate -m "first_rev"
мають знайтися моделі
Далі
alembic upgrade head
мають застосуватися зміни в БД
А далі
python main.py
Мають згенеруватися дані втаблицях, разом з даними many-to-many.



